#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct DrawCmd {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(std430, binding = 0) readonly buffer InCmds {
    DrawCmd cmds[];
} inCmds;

layout(std430, binding = 1) writeonly buffer OutCmds {
    DrawCmd cmds[];
} outCmds;

layout(std430, binding = 2) readonly buffer Models {
    mat4 models[];
} modelsBuf;

layout(std430, binding = 3) readonly buffer Bounds {
    vec4 data[]; // min, max pairs
} boundsBuf;

layout(std430, binding = 4) buffer VisibleCount {
    uint count;
};

layout(push_constant) uniform PC {
    mat4 viewProj;
} pc;

bool aabbVisible(mat4 mvp, vec3 minp, vec3 maxp) {
    vec3 corners[8];
    corners[0] = vec3(minp.x, minp.y, minp.z);
    corners[1] = vec3(maxp.x, minp.y, minp.z);
    corners[2] = vec3(minp.x, maxp.y, minp.z);
    corners[3] = vec3(maxp.x, maxp.y, minp.z);
    corners[4] = vec3(minp.x, minp.y, maxp.z);
    corners[5] = vec3(maxp.x, minp.y, maxp.z);
    corners[6] = vec3(minp.x, maxp.y, maxp.z);
    corners[7] = vec3(maxp.x, maxp.y, maxp.z);
    for (int i = 0; i < 8; ++i) {
        vec4 clip = mvp * vec4(corners[i], 1.0);
        // Vulkan NDC z is [0, w]
        if (clip.x >= -clip.w && clip.x <= clip.w &&
            clip.y >= -clip.w && clip.y <= clip.w &&
            clip.z >= 0.0 && clip.z <= clip.w) {
            return true;
        }
    }
    return false;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    // Guard: avoid out-of-range if dispatched exactly to number of commands it'll be fine
    if (idx >= inCmds.cmds.length()) return;

    // bounds stored as min,max pairs in `boundsBuf.data`
    uint bIndex = idx * 2u;
    vec3 minp = vec3(0.0);
    vec3 maxp = vec3(0.0);
    if ((bIndex + 1u) < boundsBuf.data.length()) {
        minp = boundsBuf.data[bIndex].xyz;
        maxp = boundsBuf.data[bIndex + 1u].xyz;
    } else {
        // If bounds missing, conservatively mark visible
        uint dst = atomicAdd(count, 1);
        outCmds.cmds[dst] = inCmds.cmds[idx];
        return;
    }

    mat4 model = mat4(1.0);
    if (idx < modelsBuf.models.length()) model = modelsBuf.models[idx];
    mat4 mvp = pc.viewProj * model;

    if (!aabbVisible(mvp, minp, maxp)) return;

    uint dst = atomicAdd(count, 1);
    outCmds.cmds[dst] = inCmds.cmds[idx];
}
