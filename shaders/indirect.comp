#version 450

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct DrawCmd {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout(std430, binding = 0) readonly buffer InCmds {
    DrawCmd cmds[];
} inCmds;

layout(std430, binding = 1) writeonly buffer OutCmds {
    DrawCmd cmds[];
} outCmds;

layout(std430, binding = 2) readonly buffer Models {
    mat4 models[];
} modelsBuf;

layout(std430, binding = 3) readonly buffer Bounds {
    vec4 data[]; // min, max pairs
} boundsBuf;

layout(std430, binding = 4) buffer VisibleCount {
    uint count;
};

layout(push_constant) uniform PC {
    mat4 viewProj;
    uint targetLayer; // 0 = LAYER_OPAQUE, 1 = LAYER_TRANSPARENT (unused for now - all meshes in renderer are same layer)
} pc;

// Robust AABB vs frustum test using extracting clip-space planes from the viewProj*model matrix.
// Normalize planes for stable distance tests and avoid false negatives when the camera is inside the AABB.
bool aabbVisible(mat4 mvp, vec3 minp, vec3 maxp) {
    // Extract rows: GLSL `mat4` is column-major, so mvp[i] returns a column.
    // Build rows explicitly from columns
    vec4 row0 = vec4(mvp[0][0], mvp[1][0], mvp[2][0], mvp[3][0]);
    vec4 row1 = vec4(mvp[0][1], mvp[1][1], mvp[2][1], mvp[3][1]);
    vec4 row2 = vec4(mvp[0][2], mvp[1][2], mvp[2][2], mvp[3][2]);
    vec4 row3 = vec4(mvp[0][3], mvp[1][3], mvp[2][3], mvp[3][3]);

    // Planes: left, right, bottom, top, near, far
    vec4 planes[6];
    planes[0] = row3 + row0; // left
    planes[1] = row3 - row0; // right
    planes[2] = row3 + row1; // bottom
    planes[3] = row3 - row1; // top
    planes[4] = row3 + row2; // near (Vulkan NDC z in [0,w])
    planes[5] = row3 - row2; // far

    // For each plane, normalize and test the AABB's most positive vertex
    for (int i = 0; i < 6; ++i) {
        vec3 n = planes[i].xyz;
        float d = planes[i].w;
        float len = length(n);
        if (len > 0.0) {
            n /= len;
            d /= len;
        }

        vec3 p;
        p.x = (n.x >= 0.0) ? maxp.x : minp.x;
        p.y = (n.y >= 0.0) ? maxp.y : minp.y;
        p.z = (n.z >= 0.0) ? maxp.z : minp.z;
        float dist = dot(n, p) + d;
        if (dist < 0.0) {
            // AABB is completely outside this plane
            return false;
        }
    }

    // Passed all plane tests => box intersects or is inside frustum
    return true;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    // Guard: avoid out-of-range if dispatched exactly to number of commands it'll be fine
    if (idx >= inCmds.cmds.length()) return;

    // Note: All meshes in this renderer are from the same layer (targetLayer in push constants)
    // so no per-mesh layer filtering needed - separate IndirectRenderers handle opaque vs transparent

    // bounds stored as min,max pairs in `boundsBuf.data`
    uint bIndex = idx * 2u;
    vec3 minp = vec3(0.0);
    vec3 maxp = vec3(0.0);
    if ((bIndex + 1u) < boundsBuf.data.length()) {
        minp = boundsBuf.data[bIndex].xyz;
        maxp = boundsBuf.data[bIndex + 1u].xyz;
    } else {
        // If bounds missing, conservatively mark visible
        uint dst = atomicAdd(count, 1);
        outCmds.cmds[dst] = inCmds.cmds[idx];
        return;
    }

    mat4 model = mat4(1.0);
    if (idx < modelsBuf.models.length()) model = modelsBuf.models[idx];
    mat4 mvp = pc.viewProj * model;

    // TEMP DEBUG: bypass culling to see if meshes render at all
    // if (!aabbVisible(mvp, minp, maxp)) return;

    uint dst = atomicAdd(count, 1);
    // Keep the original firstInstance (idx) so shader can look up correct model matrix
    DrawCmd cmd = inCmds.cmds[idx];
    cmd.firstInstance = idx;  // Use input index for model lookup
    outCmds.cmds[dst] = cmd;
}
