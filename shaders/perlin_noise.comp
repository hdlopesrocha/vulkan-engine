#version 450

layout (local_size_x = 16, local_size_y = 16) in;

// Use rgba8 for compatibility - we'll handle single-channel formats separately
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;
layout (binding = 1) uniform sampler2D primaryTexture;   // Primary texture to blend from
layout (binding = 2) uniform sampler2D secondaryTexture; // Secondary texture to blend to

layout (push_constant) uniform PushConstants {
    float scale;
    float octaves;
    float persistence;
    float lacunarity;
    uint seed;
    float brightness;
    float contrast;
    uint textureSize; // Size for seamless wrapping
    float time;       // Time parameter for noise evolution
} params;

// Hash function for random number generation
uint hash(uint x) {
    x += params.seed;
    x = ((x >> 16) ^ x) * 0x45d9f3bu;
    x = ((x >> 16) ^ x) * 0x45d9f3bu;
    x = (x >> 16) ^ x;
    return x;
}

// Generate random float from 0 to 1
float random(uvec2 v) {
    uint n = hash(v.x ^ hash(v.y));
    return float(n) / float(0xffffffffu);
}

// Generate random gradient vector for 3D noise (returns vec3)
vec3 randomGradient3D(ivec3 p) {
    // Wrap XY coordinates based on scale to make seamless in XY plane
    p.xy = ivec2(mod(vec2(p.xy), params.scale));
    // Z (time) doesn't wrap - allows continuous time evolution
    
    uint n = hash(uint(p.x) ^ hash(uint(p.y) ^ hash(uint(p.z))));
    
    // Generate a random 3D unit vector
    float theta = float(n) / float(0xffffffffu) * 6.28318530718; // 0 to 2*PI
    n = hash(n);
    float phi = float(n) / float(0xffffffffu) * 3.14159265359; // 0 to PI
    
    return vec3(
        sin(phi) * cos(theta),
        sin(phi) * sin(theta),
        cos(phi)
    );
}

// Smooth interpolation (smoothstep)
float fade(float t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// 3D Perlin noise function with seamless wrapping in XY, continuous in Z
float perlin3D(vec3 p) {
    // For seamless tiling in XY, we need to wrap at the scaled resolution
    float period = params.scale;
    
    // Wrap XY into the period, keep Z as-is for continuous time
    vec2 pWrappedXY = mod(p.xy, period);
    vec3 pWrapped = vec3(pWrappedXY, p.z);
    
    ivec3 p0 = ivec3(floor(pWrapped));
    vec3 f = fract(pWrapped);
    
    // Calculate the eight corner positions with wrapping in XY only
    ivec3 corners[8];
    corners[0] = ivec3(p0.x, p0.y, p0.z);
    corners[1] = ivec3(int(mod(float(p0.x + 1), period)), p0.y, p0.z);
    corners[2] = ivec3(p0.x, int(mod(float(p0.y + 1), period)), p0.z);
    corners[3] = ivec3(int(mod(float(p0.x + 1), period)), int(mod(float(p0.y + 1), period)), p0.z);
    corners[4] = ivec3(p0.x, p0.y, p0.z + 1);
    corners[5] = ivec3(int(mod(float(p0.x + 1), period)), p0.y, p0.z + 1);
    corners[6] = ivec3(p0.x, int(mod(float(p0.y + 1), period)), p0.z + 1);
    corners[7] = ivec3(int(mod(float(p0.x + 1), period)), int(mod(float(p0.y + 1), period)), p0.z + 1);
    
    // Get gradients for all 8 corners
    vec3 gradients[8];
    for (int i = 0; i < 8; i++) {
        gradients[i] = randomGradient3D(corners[i]);
    }
    
    // Calculate dot products for all 8 corners
    vec3 offsets[8];
    offsets[0] = vec3(0.0, 0.0, 0.0);
    offsets[1] = vec3(1.0, 0.0, 0.0);
    offsets[2] = vec3(0.0, 1.0, 0.0);
    offsets[3] = vec3(1.0, 1.0, 0.0);
    offsets[4] = vec3(0.0, 0.0, 1.0);
    offsets[5] = vec3(1.0, 0.0, 1.0);
    offsets[6] = vec3(0.0, 1.0, 1.0);
    offsets[7] = vec3(1.0, 1.0, 1.0);
    
    float values[8];
    for (int i = 0; i < 8; i++) {
        values[i] = dot(gradients[i], f - offsets[i]);
    }
    
    // Interpolate using fade function
    float fx = fade(f.x);
    float fy = fade(f.y);
    float fz = fade(f.z);
    
    // Trilinear interpolation
    float x00 = mix(values[0], values[1], fx);
    float x10 = mix(values[2], values[3], fx);
    float x01 = mix(values[4], values[5], fx);
    float x11 = mix(values[6], values[7], fx);
    
    float y0 = mix(x00, x10, fy);
    float y1 = mix(x01, x11, fy);
    
    return mix(y0, y1, fz);
}

// Fractal Brownian Motion (fBm) - multiple octaves of 3D Perlin noise
float fbm(vec3 p) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    
    for (int i = 0; i < int(params.octaves); i++) {
        value += amplitude * perlin3D(p * frequency);
        frequency *= params.lacunarity;
        amplitude *= params.persistence;
    }
    
    return value;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(resultImage);
    
    if (texelCoord.x >= size.x || texelCoord.y >= size.y) {
        return;
    }
    
    // Normalized coordinates [0, 1]
    vec2 uv = vec2(texelCoord) / vec2(size);
    
    // Generate 3D Perlin noise with time as the Z coordinate
    // Scale time down to slow the rate of change (0.1 = 10x slower)
    vec3 position = vec3(uv * params.scale, params.time * 0.1);
    float noise = fbm(position);
    
    // Normalize from [-1, 1] to [0, 1]
    noise = noise * 0.5 + 0.5;
    
    // Apply contrast (multiply around 0.5 midpoint)
    noise = (noise - 0.5) * params.contrast + 0.5;
    
    // Apply brightness
    noise = noise + params.brightness;
    
    // Clamp to [0, 1]
    noise = clamp(noise, 0.0, 1.0);
    
    // Sample from primary and secondary textures using existing uv
    vec3 primaryColor = texture(primaryTexture, uv).rgb;
    vec3 secondaryColor = texture(secondaryTexture, uv).rgb;
    
    // Blend between textures using noise as mask
    // noise = 0.0 -> primary texture
    // noise = 1.0 -> secondary texture
    vec3 blendedColor = mix(primaryColor, secondaryColor, noise);
    
    // Write to image
    vec4 color = vec4(blendedColor, 1.0);
    imageStore(resultImage, texelCoord, color);
}
