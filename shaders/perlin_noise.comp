#version 450

layout (local_size_x = 16, local_size_y = 16) in;

// Use rgba8 for compatibility - we'll handle single-channel formats separately
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;
layout (binding = 1) uniform sampler2D primaryTexture;   // Primary texture to blend from
layout (binding = 2) uniform sampler2D secondaryTexture; // Secondary texture to blend to

layout (push_constant) uniform PushConstants {
    float scale;
    float octaves;
    float persistence;
    float lacunarity;
    uint seed;
    float brightness;
    float contrast;
    uint textureSize; // Size for seamless wrapping
} params;

// Hash function for random number generation
uint hash(uint x) {
    x += params.seed;
    x = ((x >> 16) ^ x) * 0x45d9f3bu;
    x = ((x >> 16) ^ x) * 0x45d9f3bu;
    x = (x >> 16) ^ x;
    return x;
}

// Generate random float from 0 to 1
float random(uvec2 v) {
    uint n = hash(v.x ^ hash(v.y));
    return float(n) / float(0xffffffffu);
}

// Generate random gradient vector with wrapping for seamless textures
vec2 randomGradient(ivec2 p) {
    // Wrap coordinates to make seamless
    p = ivec2(mod(vec2(p), vec2(params.textureSize)));
    uint n = hash(uint(p.x) ^ hash(uint(p.y)));
    float angle = float(n) / float(0xffffffffu) * 6.28318530718; // 2 * PI
    return vec2(cos(angle), sin(angle));
}

// Smooth interpolation (smoothstep)
float fade(float t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Perlin noise function with seamless wrapping
float perlin(vec2 p) {
    // Wrap p to create seamless tiling
    vec2 period = vec2(params.textureSize);
    
    ivec2 p0 = ivec2(floor(p));
    ivec2 p1 = ivec2(mod(vec2(p0 + ivec2(1, 0)), period));
    ivec2 p2 = ivec2(mod(vec2(p0 + ivec2(0, 1)), period));
    ivec2 p3 = ivec2(mod(vec2(p0 + ivec2(1, 1)), period));
    p0 = ivec2(mod(vec2(p0), period));
    
    vec2 g0 = randomGradient(p0);
    vec2 g1 = randomGradient(p1);
    vec2 g2 = randomGradient(p2);
    vec2 g3 = randomGradient(p3);
    
    vec2 f = fract(p);
    
    float v0 = dot(g0, f - vec2(0.0, 0.0));
    float v1 = dot(g1, f - vec2(1.0, 0.0));
    float v2 = dot(g2, f - vec2(0.0, 1.0));
    float v3 = dot(g3, f - vec2(1.0, 1.0));
    
    float fx = fade(f.x);
    float fy = fade(f.y);
    
    float x1 = mix(v0, v1, fx);
    float x2 = mix(v2, v3, fx);
    
    return mix(x1, x2, fy);
}

// Fractal Brownian Motion (fBm) - multiple octaves of Perlin noise
float fbm(vec2 p) {
    float value = 0.0;
    float amplitude = 1.0;
    float frequency = 1.0;
    
    for (int i = 0; i < int(params.octaves); i++) {
        value += amplitude * perlin(p * frequency);
        frequency *= params.lacunarity;
        amplitude *= params.persistence;
    }
    
    return value;
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(resultImage);
    
    if (texelCoord.x >= size.x || texelCoord.y >= size.y) {
        return;
    }
    
    // Normalized coordinates [0, 1]
    vec2 uv = vec2(texelCoord) / vec2(size);
    
    // Generate Perlin noise
    float noise = fbm(uv * params.scale);
    
    // Normalize from [-1, 1] to [0, 1]
    noise = noise * 0.5 + 0.5;
    
    // Apply contrast (multiply around 0.5 midpoint)
    noise = (noise - 0.5) * params.contrast + 0.5;
    
    // Apply brightness
    noise = noise + params.brightness;
    
    // Clamp to [0, 1]
    noise = clamp(noise, 0.0, 1.0);
    
    // Sample from primary and secondary textures using existing uv
    vec3 primaryColor = texture(primaryTexture, uv).rgb;
    vec3 secondaryColor = texture(secondaryTexture, uv).rgb;
    
    // Blend between textures using noise as mask
    // noise = 0.0 -> primary texture
    // noise = 1.0 -> secondary texture
    vec3 blendedColor = mix(primaryColor, secondaryColor, noise);
    
    // Write to image
    vec4 color = vec4(blendedColor, 1.0);
    imageStore(resultImage, texelCoord, color);
}
